#!/usr/bin/env python3
"""Parse 'iw dev <iface> scan' output and display Wi-Fi generation info."""

import subprocess
import sys
import re
import os
import unicodedata


# â”€â”€ ANSI colors â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
class C:
    RST = "\033[0m"
    BOLD = "\033[1m"
    DIM = "\033[2m"
    RED = "\033[91m"
    GREEN = "\033[92m"
    YELLOW = "\033[93m"
    BLUE = "\033[94m"
    MAGENTA = "\033[95m"
    CYAN = "\033[96m"
    WHITE = "\033[97m"
    GRAY = "\033[90m"
    BG_GRAY = "\033[48;5;236m"

_ANSI_RE = re.compile(r"\033\[[^m]*m")


def dw(s: str) -> int:
    """Display width: strip ANSI, count wide chars as 2."""
    stripped = _ANSI_RE.sub("", s)
    w = 0
    for ch in stripped:
        if unicodedata.east_asian_width(ch) in ("W", "F"):
            w += 2
        else:
            w += 1
    return w


def pad(s: str, width: int) -> str:
    """Pad string with spaces to reach target display width."""
    return s + " " * max(0, width - dw(s))


# â”€â”€ Wi-Fi generation â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
GEN_INFO = {
    "Gen 7":  ("802.11be", C.MAGENTA, "ğŸš€"),
    "Gen 6E": ("802.11ax", C.CYAN,    "âš¡"),
    "Gen 6":  ("802.11ax", C.GREEN,   "âš¡"),
    "Gen 5":  ("802.11ac", C.YELLOW,  "âœ¨"),
    "Gen 4":  ("802.11n",  C.RED,     "ğŸ“¡"),
    "Legacy": ("802.11a/b/g", C.GRAY, "ğŸŒ"),
}


def get_wifi_gen(caps: set[str], freq: float) -> str:
    if "EHT" in caps:
        return "Gen 7"
    if "HE" in caps:
        return "Gen 6E" if freq >= 5925 else "Gen 6"
    if "VHT" in caps:
        return "Gen 5"
    if "HT" in caps:
        return "Gen 4"
    return "Legacy"


def signal_bar(dbm: float) -> str:
    if dbm >= -50:
        bars, color, emoji = "â–ˆâ–ˆâ–ˆâ–ˆ", C.GREEN, "ğŸŸ¢"
    elif dbm >= -60:
        bars, color, emoji = "â–ˆâ–ˆâ–ˆâ–‘", C.GREEN, "ğŸŸ¢"
    elif dbm >= -70:
        bars, color, emoji = "â–ˆâ–ˆâ–‘â–‘", C.YELLOW, "ğŸŸ¡"
    elif dbm >= -80:
        bars, color, emoji = "â–ˆâ–‘â–‘â–‘", C.RED, "ğŸŸ "
    else:
        bars, color, emoji = "â–‘â–‘â–‘â–‘", C.RED, "ğŸ”´"
    return f"{emoji} {color}{bars}{C.RST} {C.DIM}{dbm:.0f}dBm{C.RST}"


def util_bar(util_str: str) -> str:
    """Channel utilisation as percentage with color."""
    try:
        num, den = util_str.split("/")
        pct = int(num) / int(den) * 100
    except (ValueError, ZeroDivisionError):
        return f"{C.DIM}â”€{C.RST}"
    if pct < 30:
        color = C.GREEN
    elif pct < 60:
        color = C.YELLOW
    else:
        color = C.RED
    return f"{color}{pct:.0f}%{C.RST}"


def get_channel_width(text: str) -> str:
    m = re.search(r"channel width: \d+ \(([^)]+)\)", text)
    if m:
        return m.group(1)
    if "HT20/HT40" in text:
        return "40 MHz"
    if "HT20" in text:
        return "20 MHz"
    return ""


def get_max_streams(text: str) -> int:
    max_ss = 0
    for m in re.finditer(r"(\d+) streams: MCS", text):
        max_ss = max(max_ss, int(m.group(1)))
    return max_ss


def load_oui_db() -> dict[str, str]:
    """Load OUI database from oui.db file next to this script."""
    oui = {}
    db_path = os.path.join(os.path.dirname(os.path.abspath(__file__)), "data", "oui.db")
    if not os.path.exists(db_path):
        return oui
    with open(db_path) as f:
        for line in f:
            parts = line.strip().split("\t", 1)
            if len(parts) == 2:
                oui[parts[0]] = parts[1]
    return oui


def oui_lookup(bssid: str, oui_db: dict[str, str]) -> str:
    """Look up vendor from BSSID using OUI database.
    Returns empty string for locally administered MACs (randomized)
    unless a match is found by clearing the local bit."""
    prefix = bssid.replace(":", "")[:6].lower()
    # Direct lookup
    if prefix in oui_db:
        return oui_db[prefix]
    # Check if locally administered (bit 1 of first byte)
    first_byte = int(prefix[:2], 16)
    if first_byte & 0x02:
        # Try clearing the local-admin bit to find the base OUI
        global_byte = first_byte & ~0x02
        global_prefix = f"{global_byte:02x}{prefix[2:]}"
        if global_prefix in oui_db:
            return oui_db[global_prefix]
    return ""


def band_label(freq: float) -> str:
    if freq >= 5925:
        return "6 GHz"
    if freq >= 5000:
        return "5 GHz"
    return "2.4 GHz"


def band_emoji(band: str) -> str:
    if "6" in band and "2.4" not in band:
        return "ğŸŸ£"
    if "5" in band:
        return "ğŸ”µ"
    return "ğŸŸ¤"


def get_wireless_interfaces() -> list[str]:
    """Get wireless interface names from 'iw dev'."""
    try:
        result = subprocess.run(
            ["iw", "dev"], capture_output=True, text=True, check=True,
        )
        return re.findall(r"Interface\s+(\S+)", result.stdout)
    except (subprocess.CalledProcessError, FileNotFoundError):
        return []


def parse_scan(text: str) -> list[dict]:
    networks = []
    blocks = re.split(r"(?=BSS [0-9a-f:]{17})", text)

    for block in blocks:
        if not block.strip():
            continue

        net = {
            "bssid": "",
            "ssid": "",
            "freq": 0.0,
            "signal": 0.0,
            "security": "Open",
            "caps": set(),
            "channel_width": "",
            "streams": 0,
            "associated": False,
            "channel": "",
            "wps": False,
            "clients": "",
            "util": "",
            "mu_mimo": False,
            "twt": False,
            "auth": "",
            "vendor": "",
        }

        # BSSID
        m = re.search(r"BSS ([0-9a-f:]{17})", block)
        if m:
            net["bssid"] = m.group(1)

        net["associated"] = "-- associated" in block

        # SSID
        m = re.search(r"SSID: ([^\t\n]+)", block)
        if m:
            net["ssid"] = m.group(1).strip()

        # Frequency
        m = re.search(r"freq: ([\d.]+)", block)
        if m:
            net["freq"] = float(m.group(1))

        # Signal
        m = re.search(r"signal: (-?[\d.]+)", block)
        if m:
            net["signal"] = float(m.group(1))

        # Security / Auth
        if "RSN:" in block:
            net["security"] = "WPA2"
        elif "WPA:" in block:
            net["security"] = "WPA"
        if "802.1X" in block:
            net["security"] = "Enterprise"

        # Auth suites
        m = re.search(r"Authentication suites: ([^\t\n*]+)", block)
        if m:
            net["auth"] = m.group(1).strip()

        # SAE = WPA3
        if "SAE" in net["auth"]:
            net["security"] = "WPA3"
        if "PSK SAE" in net["auth"]:
            net["security"] = "WPA2/3"

        # Capabilities
        if "HT capabilities:" in block or "HT operation:" in block:
            net["caps"].add("HT")
        if "VHT capabilities:" in block or "VHT operation:" in block:
            net["caps"].add("VHT")
        if "HE capabilities:" in block or "HE Operation:" in block:
            net["caps"].add("HE")
        if "EHT capabilities:" in block or "EHT Operation:" in block:
            net["caps"].add("EHT")

        # Channel
        m = re.search(r"primary channel: (\d+)", block)
        if m:
            net["channel"] = m.group(1)

        # Channel width
        net["channel_width"] = get_channel_width(block)

        # Spatial streams
        net["streams"] = get_max_streams(block)

        # WPS
        net["wps"] = "WPS:" in block or "Wi-Fi Protected Setup" in block

        # BSS Load â€” station count (clients)
        m = re.search(r"station count: (\d+)", block)
        if m:
            net["clients"] = m.group(1)

        # Channel utilisation
        m = re.search(r"channel utilisation: (\d+/\d+)", block)
        if m:
            net["util"] = m.group(1)

        # MU-MIMO
        net["mu_mimo"] = "MU Beamformer" in block

        # TWT (Target Wake Time)
        net["twt"] = "TWT Responder" in block

        # Vendor from WPS
        m = re.search(r"Manufacturer: ([^\t\n*]+)", block)
        if m:
            net["vendor"] = m.group(1).strip()
        if not net["vendor"]:
            m = re.search(r"Device name: ([^\t\n*]+)", block)
            if m:
                net["vendor"] = m.group(1).strip()

        # Derived
        net["gen"] = get_wifi_gen(net["caps"], net["freq"])
        net["band"] = band_label(net["freq"])

        if net["ssid"]:
            networks.append(net)

    return networks


def main():
    if not sys.stdin.isatty():
        text = sys.stdin.read()
    else:
        # Use explicit interface arg, or auto-detect from system
        if len(sys.argv) > 1:
            ifaces = [sys.argv[1]]
        else:
            ifaces = get_wireless_interfaces()
            if not ifaces:
                print("No wireless interfaces found.", file=sys.stderr)
                sys.exit(1)

        text = ""
        for iface in ifaces:
            try:
                result = subprocess.run(
                    ["sudo", "iw", "dev", iface, "scan"],
                    capture_output=True, text=True, check=True,
                )
                text += result.stdout
            except subprocess.CalledProcessError as e:
                print(f"Error scanning {iface}: {e.stderr.strip()}", file=sys.stderr)

        if not text:
            print("No scan results from any interface.", file=sys.stderr)
            sys.exit(1)

    networks = parse_scan(text)
    if not networks:
        print("No networks found.")
        sys.exit(0)

    # OUI vendor lookup
    oui_db = load_oui_db()
    if oui_db:
        for n in networks:
            if not n["vendor"]:
                n["vendor"] = oui_lookup(n["bssid"], oui_db)

    # Sort: group by SSID (associated first, then alphabetical), within group by signal
    def sort_key(n):
        return (
            not n["associated"],
            n["ssid"].lower(),
            n["signal"],
        )
    networks.sort(key=sort_key)

    # Count APs per SSID
    ssid_counts: dict[str, int] = {}
    for n in networks:
        ssid_counts[n["ssid"]] = ssid_counts.get(n["ssid"], 0) + 1

    unique_ssids = len(ssid_counts)

    # â”€â”€ Column widths â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    COL_ICON = 4
    COL_SSID = 26
    COL_BAND = 10
    COL_CH = 4
    COL_SIGNAL = 18
    COL_SEC = 9
    COL_GEN = 8
    COL_WIDTH = 14
    COL_SS = 3
    COL_LOAD = 5
    COL_UTIL = 5
    COL_FLAGS = 12
    COL_VENDOR = 16
    COL_APS = 3

    total_w = (COL_ICON + COL_SSID + COL_BAND + COL_CH + COL_SIGNAL + COL_SEC
               + COL_GEN + COL_WIDTH + COL_SS + COL_LOAD + COL_UTIL
               + COL_FLAGS + COL_VENDOR + COL_APS + 8)

    # â”€â”€ Header â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    print()
    print(f"  {C.BOLD}{C.CYAN}ğŸ“¶ Wi-Fi Scanner{C.RST}  {C.DIM}â”€  {len(networks)} APs found, {unique_ssids} unique networks{C.RST}")
    print()

    hdr = (
        f"{pad('', COL_ICON)}"
        f"{pad('SSID', COL_SSID)}"
        f"{pad('Band', COL_BAND)}"
        f"{pad('Ch', COL_CH)}"
        f"{pad('Signal', COL_SIGNAL)}"
        f"{pad('Security', COL_SEC)}"
        f"{pad('Gen', COL_GEN)}"
        f"{pad('Width', COL_WIDTH)}"
        f"{pad('SS', COL_SS)}"
        f"{pad('ğŸ‘¥', COL_LOAD)}"
        f"{pad('Load', COL_UTIL)}"
        f"{pad('Features', COL_FLAGS)}"
        f"{pad('Vendor', COL_VENDOR)}"
        f"{'APs':>{COL_APS}}"
    )
    print(f"  {C.BOLD}{C.WHITE}{hdr}{C.RST}")
    print(f"  {C.DIM}{'â”€' * total_w}{C.RST}")

    prev_ssid = None
    row_idx = 0

    for n in networks:
        gen = n["gen"]
        std, gen_color, gen_emoji = GEN_INFO[gen]

        # Separator between SSID groups
        is_new_group = n["ssid"] != prev_ssid
        if prev_ssid is not None and is_new_group:
            print(f"  {C.DIM}{'Â·' * total_w}{C.RST}")
            row_idx = 0

        # Icon
        col_icon = pad(f" {gen_emoji} ", COL_ICON)

        # SSID â€” show name on first row of group only
        ssid_str = n["ssid"][:24]
        if is_new_group:
            if n["associated"]:
                col_ssid = pad(f"{C.GREEN}{C.BOLD}{ssid_str}{C.RST} ğŸ”—", COL_SSID)
            else:
                col_ssid = pad(f"{C.WHITE}{ssid_str}{C.RST}", COL_SSID)
        else:
            col_ssid = pad(f"{C.DIM}â””{C.RST}", COL_SSID)

        # Band
        band = n["band"]
        col_band = pad(f"{band_emoji(band)}{band}", COL_BAND)

        # Channel
        ch = n["channel"] or "â”€"
        col_ch = pad(ch, COL_CH)

        # Signal
        col_signal = pad(signal_bar(n["signal"]), COL_SIGNAL)

        # Security
        sec = n["security"]
        if sec == "Open":
            col_sec = pad(f"{C.RED}Open{C.RST}", COL_SEC)
        elif sec == "WPA3":
            col_sec = pad(f"{C.GREEN}WPA3{C.RST}", COL_SEC)
        elif sec == "WPA2/3":
            col_sec = pad(f"{C.GREEN}WPA2/3{C.RST}", COL_SEC)
        elif sec == "Enterprise":
            col_sec = pad(f"{C.CYAN}802.1X{C.RST}", COL_SEC)
        else:
            col_sec = pad(sec, COL_SEC)

        # Gen
        col_gen = pad(f"{gen_color}{C.BOLD}{gen}{C.RST}", COL_GEN)

        # Width
        width = n["channel_width"] or "â”€"
        col_width = pad(width, COL_WIDTH)

        # Spatial streams
        ss = str(n["streams"]) if n["streams"] else "â”€"
        col_ss = pad(ss, COL_SS)

        # Clients (station count)
        if n["clients"]:
            clients_n = int(n["clients"])
            if clients_n == 0:
                col_load = pad(f"{C.DIM}0{C.RST}", COL_LOAD)
            elif clients_n <= 5:
                col_load = pad(f"{C.GREEN}{clients_n}{C.RST}", COL_LOAD)
            elif clients_n <= 15:
                col_load = pad(f"{C.YELLOW}{clients_n}{C.RST}", COL_LOAD)
            else:
                col_load = pad(f"{C.RED}{clients_n}{C.RST}", COL_LOAD)
        else:
            col_load = pad(f"{C.DIM}â”€{C.RST}", COL_LOAD)

        # Channel utilisation
        col_util = pad(util_bar(n["util"]), COL_UTIL)

        # Feature flags
        flags = []
        if n["wps"]:
            flags.append(f"{C.YELLOW}WPS{C.RST}")
        if n["mu_mimo"]:
            flags.append(f"{C.CYAN}MU{C.RST}")
        if n["twt"]:
            flags.append(f"{C.GREEN}TWT{C.RST}")
        col_flags = pad(" ".join(flags) if flags else f"{C.DIM}â”€{C.RST}", COL_FLAGS)

        # Vendor
        vendor = n["vendor"][:14] if n["vendor"] else ""
        col_vendor = pad(f"{C.DIM}{vendor}{C.RST}" if vendor else f"{C.DIM}â”€{C.RST}", COL_VENDOR)

        # APs count â€” only on first row of group
        count = str(ssid_counts[n["ssid"]]) if is_new_group else ""

        # Row background
        bg = C.BG_GRAY if row_idx % 2 == 0 else ""
        rst = C.RST if bg else ""

        print(
            f"  {bg}"
            f"{col_icon}"
            f"{col_ssid}"
            f"{col_band}"
            f"{col_ch}"
            f"{col_signal}"
            f"{col_sec}"
            f"{col_gen}"
            f"{col_width}"
            f"{col_ss}"
            f"{col_load}"
            f"{col_util}"
            f"{col_flags}"
            f"{col_vendor}"
            f"{count:>{COL_APS}}"
            f"{rst}"
        )

        prev_ssid = n["ssid"]
        row_idx += 1

    # â”€â”€ Legend â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    print()
    print(f"  {C.DIM}{'â”€' * total_w}{C.RST}")
    print(f"  {C.DIM}ğŸ”— Connected  â”‚  SS = Spatial Streams  â”‚  ğŸ‘¥ = Connected clients  â”‚  Load = Channel utilisation{C.RST}")
    print(f"  {C.DIM}WPS = Wi-Fi Protected Setup  â”‚  MU = MU-MIMO beamforming  â”‚  TWT = Target Wake Time (power save){C.RST}")
    print(f"  {C.DIM}ğŸŸ¤ 2.4GHz  ğŸ”µ 5GHz  ğŸŸ£ 6GHz  â”‚  ğŸš€ Gen7  âš¡ Gen6/6E  âœ¨ Gen5  ğŸ“¡ Gen4  ğŸŒ Legacy{C.RST}")
    print()


if __name__ == "__main__":
    main()
